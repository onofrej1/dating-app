// https://vertabelo.com/blog/a-dating-app-data-model/

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Question {
  id            Int     @id @default(autoincrement())
  name          String
  title         String
  text          String?
  type          String
  isRequired    Boolean @default(false)
  allowMultiple Boolean @default(false)
  category      String
  order         Int     @default(0)

  questionChoices QuestionChoice[]

  userInfo        UserInfo[]
  userPreferences UserPreferences[]
}

model QuestionChoice {
  id           Int      @id @default(autoincrement())
  title        String
  questionId   Int
  question     Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  displayOrder Int

  userInfo        UserInfo[]
  userPreferences UserPreferences[]
}

model UserInfo {
  id               Int             @id @default(autoincrement())
  userId           String
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId       Int
  question         Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionChoiceId Int?
  questionChoice   QuestionChoice? @relation(fields: [questionChoiceId], references: [id], onDelete: Cascade)
  weight           Int             @default(0)
  value            String?

  //@@unique([userId, questionId], name: "questionIdentifier")
}

model UserPreferences {
  id               Int             @id @default(autoincrement())
  userId           String
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  questionId       Int
  question         Question        @relation(fields: [questionId], references: [id], onDelete: Cascade)
  questionChoiceId Int?
  questionChoice   QuestionChoice? @relation(fields: [questionChoiceId], references: [id], onDelete: Cascade)
  weight           Int             @default(0)
  value            String?
}

model UserLocation {
  id      Int     @id @default(autoincrement())
  userId  String  @unique
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  country String?
  region  Region?
  city    String?
}

enum Region {
  KE
  BA
  BB
  PO
  NR
  TC
  TV
  ZA
}

model User {
  id            String    @id
  name          String
  nickname      String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  gender        String?
  genderSearch  String?
  dob           DateTime?
  bio           String?   @db.Text()
  popularity    Int       @default(0)
  lastLogin     DateTime?
  sessions      Session[]
  accounts      Account[]

  role       String?
  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  conversationMembers ConversationMember[]
  messages            Message[]
  userLocation        UserLocation?
  userPhotos          UserPhoto[]  
  givenGrades         Grade[]              @relation("givenGrades")
  receivedGrades      Grade[]              @relation("receivedGrades")
  blockedUsers        BlockUser[]          @relation("blockedUsers")
  blockedByUsers      BlockUser[]          @relation("blockedByUsers")
  userInfo            UserInfo[]
  userPreferences     UserPreferences[]

  @@unique([email])
  @@map("user")
}

model UserPhoto {
  id      Int      @id @default(autoincrement())
  userId  String
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  link    String
  details String
  addedAt DateTime
  active  Boolean  @default(false)
}

model Conversation {
  id                  Int                  @id @default(autoincrement())
  name                String?
  isGroup             Boolean
  lastMessage         Message?             @relation("lastMessage", fields: [lastMessageId], references: [id])
  lastMessageId       Int?
  conversationMembers ConversationMember[]
  messages            Message[]
}

model ConversationMember {
  id                Int          @id @default(autoincrement())
  user              User         @relation(fields: [userId], references: [id])
  userId            String
  conversation      Conversation @relation(fields: [conversationId], references: [id])
  conversationId    Int
  lastSeenMessage   Message?     @relation(fields: [lastSeenMessageId], references: [id])
  lastSeenMessageId Int?
}

model Message {
  id                  Int                  @id @default(autoincrement())
  sender              User                 @relation(fields: [senderId], references: [id])
  senderId            String
  conversation        Conversation         @relation(fields: [conversationId], references: [id])
  conversationId      Int
  content             String               @db.Text
  type                String
  createdAt           DateTime             @default(now())
  conversationMembers ConversationMember[]
  lastConversations   Conversation[]       @relation("lastMessage")
}

model Grade {
  id             Int    @id @default(autoincrement())
  givenUserId    String
  givenUser      User   @relation("givenGrades", fields: [givenUserId], references: [id], onDelete: Cascade)
  receivedUserId String
  receivedUser   User   @relation("receivedGrades", fields: [receivedUserId], references: [id], onDelete: Cascade)
  grad           Int
}

model BlockUser {
  id            Int    @id @default(autoincrement())
  userId        String
  user          User   @relation("blockedUsers", fields: [userId], references: [id], onDelete: Cascade)
  blockedUserId String
  blockedUser   User   @relation("blockedByUsers", fields: [blockedUserId], references: [id], onDelete: Cascade)
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}
